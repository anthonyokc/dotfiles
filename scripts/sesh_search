#!/bin/bash

# List all existing sesh sessions
list_sesh() {
  sesh list -i -t -c
}

# Find all code directories under ~/code, accounting for multiple Git worktrees
list_code_repos() {
  find ~/code -mindepth 2 -maxdepth 2 -type d | while read -r dir; do
    if [ -d "$dir/.git" ]; then
      # If it has multiple worktrees, list them (except the first line)
      if [ "$(git --git-dir="$dir/.git" worktree list 2>/dev/null | wc -l)" -gt 1 ]; then
        git --git-dir="$dir/.git" worktree list | tail -n +2 | awk '{print $1}'
      else
        echo "$dir"
      fi
    else
      echo "$dir"
    fi
  done
}

# Convert directory paths to your icon-based format, then sort by:
#   1) Repository name
#   2) main/master branches first (flag=0), everything else (flag=1)
#   3) Branch name
format_and_sort() {
  sed 's|^.*/code/[[:alnum:]]*/|ï„” |' \
  | awk 'BEGIN { OFS="\t" }
         {
           # Original line might look like: "ï„” reponame/branch"
           original = $0
           sub(/^ï„” /, "", original)
           split(original, parts, "/")

           # parts[1] = repo name, parts[2] = branch name (if any)
           repo   = parts[1]
           branch = (length(parts) > 1 ? parts[2] : "")

           # If no branch name, treat it as "main" for sorting
           flag = (branch == "main" || branch == "master" || branch == "") ? 0 : 1

           # We store: [repo] [flag] [branch] [original line]
           print repo, flag, branch, $0
         }' \
  | sort -t $'\t' -k1,1 -k2,2n -k3,3 \
  | cut -f4-
}

main() {
  # 1. Capture existing sessions
  local sessions
  sessions="$(list_sesh)"

  # 2. Capture and sort code repo lines
  local repos
  repos="$(list_code_repos | format_and_sort)"

  # 3. Combine sessions + repos, pipe to gum filter, then connect
  sesh connect "$(
    {
      printf "%s\n" "$sessions"
      printf "%s\n" "$repos"
    } | gum filter --limit 1 --placeholder 'Pick a session' --height 50 --width 30 --prompt='ðŸ”Ž '
  )"
}

main "$@"
