#!/bin/bash
# sesh_search - Search and connect to existing sesh sessions or create new ones from code repos
set -euo pipefail

# List all existing sesh sessions
list_sesh() {
  sesh list -i -t -c
}

# Find all code directories under ~/code, accounting for multiple Git worktrees
list_code_repos() {
  fd -td . ~/code --min-depth 2 --max-depth 2 |
    xargs -n1 -P"$(nproc)" bash -c '
      dir="${1%/}";
      if [ -d "$dir/.git/worktrees" ]; then
        for wt in "$dir"/*; do
          echo $wt
        done
      else
        echo "$dir"
      fi
    ' _
}

# Convert directory paths to your icon-based format, then sort by:
#   1) Repository name
#   2) main/master branches first (flag=0), everything else (flag=1)
#   3) Branch name
format_and_sort() {
  sed 's|^.*/code/[[:alnum:]]*/|ï„” |' |
    awk 'BEGIN { OFS="\t" }
         {
           # Original line might look like: "ï„” reponame/branch"
           original = $0
           sub(/^ï„” /, "", original)
           split(original, parts, "/")

           # parts[1] = repo name, parts[2] = branch name (if any)
           repo   = parts[1]
           branch = (length(parts) > 1 ? parts[2] : "")

           # If no branch name, treat it as "main" for sorting
           flag = (branch == "main" || branch == "master" || branch == "") ? 0 : 1

           # We store: [repo] [flag] [branch] [original line]
           print repo, flag, branch, $0
         }' |
    sort -t $'\t' -k1,1 -k2,2n -k3,3 |
    cut -f4- # Output only the formatted line and the original dir (tab separated)
}

main() {
  # 1. Capture existing sessions
  local sessions
  sessions="$(list_sesh)"

  # 2. Capture and sort code repo lines
  local repos
  repos="$(list_code_repos | format_and_sort)"

  # 3. Combine sessions + repos, pipe to gum filter
  local selected_sesh
  selected_sesh=$(
    {
      printf "%s\n" "$sessions"
      printf "%s\n" "$repos"
    } | gum filter --limit 1 --placeholder 'Pick a session' --height 50 --width 40 --prompt='ðŸ”Ž ' --header="Sesh Selector" --header.foreground 3
  )

  # 5. Connect to the selected session
  sesh connect "$selected_sesh"

  # 6. If the selection was a formatted repo (contains '/' and starts with 'ï„” '),
  #    rename the tmux session by removing the 'ï„” ' prefix.
  #    We check specifically for the prefix now.
  if [[ "$selected_sesh" == */* && "$selected_sesh" == "ï„” "* ]]; then
    echo "The selected session is a repo, so we need to rename it."
    # Remove the "ï„” " prefix to get the desired final session name
    local target_name="${selected_sesh#"ï„” "}"

    echo "Detected repo selection: '$selected_sesh'. Attempting rename to: '$target_name'"

    # Use tmux rename-session.
    # The '-t "$selected_sesh"' targets the session that should have just been
    # created or connected to by 'sesh connect' using the *original* selected name.
    if tmux rename-session "$target_name"; then
      echo "Session successfully renamed to '$target_name'."
      # Update the variable if you need the new name later in the script
      selected_sesh="$target_name"
    else
      echo "Error: Failed to rename session '$selected_sesh' to '$target_name'." >&2
      # Consider how to handle this error - maybe exit, maybe continue?
    fi
  else
    echo "Selected '$selected_sesh'. No rename needed or condition not met."
  fi

}

main "$@"
